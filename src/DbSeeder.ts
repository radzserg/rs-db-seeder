import RefColumn from "./RefColumn";
import { IStorageWriter } from "./IStorageWriter";
export type DataProvider = (data?: any) => any;

interface IFactory {
    id: string; // unique factory ID
    tableName: string; // name of the table where factory will write data
    dataProvider: DataProvider; // function that will create mock data
    // custom insert implementation, (useful for non-trivial cases)
    insert?: (data?: any) => Promise<any>;
    refs?: RefColumn[];
}

/**
 * Allows to easily seed DB. Useful for tests.
 */
export default class DbSeeder {
    private factories: IFactory[] = [];
    private storage: IStorageWriter;

    constructor(storage: IStorageWriter) {
        this.storage = storage;
    }

    public addFactory(factory: IFactory) {
        this.factories.push(factory);
    }

    /**
     * Inserts data to DB
     * @param id - factory name
     * @param data - optional data that will override data generated by dataProvider
     */
    public async insert(id: string, data: any = {}) {
        const factory = this.getFactory(id);
        const fakeData = factory.dataProvider(data);

        const refs = factory.refs ?? [];
        const refData: any = {};
        await Promise.all(
            refs.map(async (ref) => {
                const nestedData: any = fakeData
                    ? fakeData[ref.getFactoryId()]
                    : {};
                delete fakeData[ref.getFactoryId()];
                const fieldName = ref.getRefId();
                if (typeof fakeData[fieldName] !== "undefined") {
                    refData[fieldName] = fakeData[fieldName];
                    return;
                }
                if (nestedData && nestedData[ref.getId()]) {
                    refData[fieldName] = nestedData[ref.getId()];
                    return;
                }
                const nested = await this.insert(
                    ref.getFactoryId(),
                    nestedData
                );
                refData[fieldName] = nested[ref.getId()];
            })
        );

        const resultedData: any = {
            ...fakeData,
            ...refData,
        };

        if (factory.insert) {
            return await factory.insert(resultedData);
        } else {
            return await this.storage.insert(factory.tableName, resultedData);
        }
    }

    /**
     * Builds data
     * @param id
     * @param data
     */
    public build(id: string, data?: any): any {
        const factory = this.getFactory(id);
        return factory.dataProvider(data);
    }

    private getFactory(id: string): IFactory {
        const factory = this.factories.find((f) => f.id === id);
        if (factory === undefined) {
            throw new Error(`Definition ${id} is not set up`);
        }
        return factory;
    }
}
