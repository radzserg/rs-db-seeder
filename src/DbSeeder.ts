import RefColumn from "./RefColumn";
import { IStorageWriter } from "./IStorageWriter";

export type DataProvider = <T extends FakeData>(
    data?: Partial<T>
) => Partial<T>;

interface IFactory {
    id: string; // unique factory ID
    tableName: string; // name of the table where factory will write data
    dataProvider: DataProvider; // function that will create mock data
    insert?: () => any; // custom insert implementation, (useful for non-trivial cases)
}

type FakeData = {
    [key: string]: any | RefColumn;
};

/**
 * Allows to easily seed DB. Useful for tests.
 */
export default class DbSeeder {
    private factories: IFactory[] = [];
    private storage: IStorageWriter;

    constructor(storage: IStorageWriter) {
        this.storage = storage;
    }

    public addFactory(factory: IFactory) {
        this.factories.push(factory);
    }

    /**
     * Inserts data to DB
     * @param id - factory name
     * @param data - optional data that will override data generated by dataProvider
     */
    public async insert<T extends FakeData>(id: string, data?: Partial<T>) {
        const factory = this.getFactory(id);
        const fakeData = factory.dataProvider(data);

        const resultedData: any = {};
        for (const fieldName of Object.keys(fakeData)) {
            const fieldValue: any = fakeData[fieldName];
            if (fieldValue instanceof RefColumn) {
                const refId = fieldValue.getRefId();
                if (fakeData[refId] === undefined) {
                    const nestedData = data ? data[fieldName] : {};
                    const refData = await this.insert(
                        fieldValue.getFactoryId(),
                        nestedData
                    );
                    resultedData[refId] = refData[fieldValue.getId()];
                }
            } else {
                resultedData[fieldName] = fieldValue;
            }
        }

        return await this.storage.insert(factory.tableName, resultedData);
    }

    /**
     * Builds data
     * @param id
     * @param data
     */
    public build<T extends FakeData>(id: string, data?: Partial<T>): any {
        const factory = this.getFactory(id);
        const fakeData = factory.dataProvider(data);

        const resultedData: any = {};
        for (const fieldName of Object.keys(fakeData)) {
            const fieldValue: any = fakeData[fieldName];
            // do not build data for references
            if (!(fieldValue instanceof RefColumn)) {
                resultedData[fieldName] = fieldValue;
            }
        }
        return resultedData;
    }

    private getFactory(id: string): IFactory {
        const factory = this.factories.find((f) => f.id === id);
        if (factory === undefined) {
            throw new Error(`Definition ${id} is not set up`);
        }
        return factory;
    }
}
